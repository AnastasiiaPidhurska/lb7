Лабораторна робота №7

Тема: Threads – взаємовиключення. Робота з блокуваннями читання-запису (r/w lock)

Мета роботи

Метою лабораторної роботи є дослідження особливостей паралельної роботи потоків у середовищі Linux, ознайомлення з механізмами синхронізації доступу до спільних ресурсів за допомогою засобів бібліотеки PThreads, а також набуття практичних навичок використання блокувань читання-запису (pthread_rwlock) для узгодженої роботи потоків.
У результаті виконання роботи студент має зрозуміти принципи виникнення умов перегонів, шляхи їх уникнення, а також навчитися створювати багатопотокові програми, у яких кілька потоків одночасно працюють зі спільними даними без порушення узгодженості.

Умови завдання

Необхідно розробити програму, у якій одночасно працюють декілька потоків-читачів і потоків-письменників, які звертаються до спільного ресурсу — масиву цілих чисел.
Кількість елементів масиву задається користувачем при запуску програми. Якщо параметр не задано, використовується значення за замовчуванням (наприклад, 10 елементів).

Потоки-письменники записують у випадкові елементи масиву псевдовипадкові значення з певного діапазону (0–99).

Потоки-читачі вибирають випадковий індекс та зчитують значення елемента масиву.

Окремий потік-монітор періодично (раз на кілька секунд) виводить поточний стан масиву на екран.

Для забезпечення узгодженого доступу використовується механізм блокування читання-запису (pthread_rwlock).

Програма працює певний заданий час (наприклад, 10 секунд), після чого завершує роботу.

Вимоги до програмного рішення

Програма має бути реалізована мовою C з використанням бібліотеки PThreads.

Для синхронізації доступу потоків до спільного ресурсу необхідно застосувати rwlock.

Код повинен бути структурований і складатися з кількох файлів (main.c, array_rw.c, array_rw.h).

Компіляція програми здійснюється за допомогою Makefile.

Повинен бути створений файл README.md із поясненням структури проєкту, способу запуску та прикладом роботи.

Робота програми має завершуватись коректно після завершення всіх потоків.

Репозиторій повинен містити не менше п’яти коммітів, що демонструють історію розробки.

Структура проєкту
lab7_task2/
├── include/
│   └── array_rw.h
├── src/
│   ├── main.c
│   └── array_rw.c
├── Makefile
└── README.md

Хід виконання роботи

На початку виконання лабораторної роботи було створено заголовковий файл array_rw.h, який містить визначення структури SharedArray і прототипи функцій для ініціалізації, знищення масиву та запуску потоків.

Далі у файлі array_rw.c реалізовано основну логіку роботи з потоками.
У програмі створюється спільна структура SharedArray, яка містить масив чисел, розмір масиву, об’єкт блокування pthread_rwlock_t та прапорець стану виконання.

Потоки працюють наступним чином:

Потоки-письменники (writer_thread) — у циклі вибирають випадковий індекс у масиві, генерують випадкове число та записують його у відповідний елемент. Для запису використовується блокування pthread_rwlock_wrlock, яке забезпечує взаємовиключення при модифікації даних.

Потоки-читачі (reader_thread) — у циклі вибирають випадковий індекс та зчитують значення цього елемента, використовуючи pthread_rwlock_rdlock, яке дозволяє одночасно читати кільком потокам.

Потік-монітор (monitor_thread) — з певною періодичністю (2 секунди) виводить поточний стан усього масиву, не блокуючи роботу інших потоків на тривалий час.

Після створення потоків програма працює визначений час (sleep(run_time)), після чого встановлює прапорець running = 0 і очікує завершення всіх потоків за допомогою pthread_join.

Приклад виконання програми

Компіляція програми:

make


Запуск програми з масивом на 15 елементів:

./lab7_task2 15


Результат роботи програми:

[Writer 140134206404352] arr[4] = 83
        [Reader 140134198011648] arr[9] = 83
        [Reader 140134189618944] arr[4] = 83
Array state: 0 0 0 0 83 0 0 0 0 0 0 0 0 0 0
[Writer 140134206404352] arr[2] = 47
        [Reader 140134198011648] arr[2] = 47
Array state: 0 0 47 0 83 0 0 0 0 0 0 0 0 0 0
Program finished.

Аналіз результатів

У результаті виконання програми спостерігається коректна взаємодія потоків:

Потоки-письменники змінюють елементи масиву без конфліктів.

Потоки-читачі одночасно зчитують дані без блокування один одного.

Потік-монітор регулярно виводить актуальний стан масиву, демонструючи узгодженість даних.

Відсутні умови перегонів (race conditions) та взаємоблокування (deadlock).

Використання rwlock показало, що цей механізм є ефективнішим, ніж звичайний м’ютекс, оскільки дозволяє кільком потокам паралельно читати дані, не блокуючи один одного.

Висновки

У ході виконання лабораторної роботи було:

створено багатопотокову програму з використанням бібліотеки pthread;

реалізовано синхронізований доступ до спільних даних за допомогою pthread_rwlock;

вивчено різницю між блокуваннями читання та запису;

перевірено на практиці механізми запобігання умовам перегонів;

досягнуто стабільної паралельної роботи без помилок та зависань.

Робота дозволила глибше зрозуміти принципи багатопотокового програмування, особливості використання засобів взаємовиключення та ефективної синхронізації в Linux.
